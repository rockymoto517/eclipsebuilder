Array.prototype.intersect=function(...e){for(const t of e)if(!Array.isArray(t))throw"This function only accepts Array objects!";return this.filter(t=>{let s=!0;for(let i=0;i<e.length&&s;i++)s=e[i].includes(t);return s})},Array.prototype.reverseMiddle=function(){const e=this.slice(1,this.length-1);for(let t=0;t<e.length;t+=2)[e[t],e[t+1]]=[e[t+1],e[t]];return[this[0],...e,this[this.length-1]]},String.prototype.toCamelCase=function(){return this.replace(/(_\w)/g,e=>e[1].toUpperCase())},Number.prototype.maybeRound=function(e){return parseFloat(this.toFixed(e))};class e{constructor(){throw new Error("This class isn't supposed to be initialized")}static resolveRequire(e,t,s){return s.get("system.requires."+e)({rep:{name:t}})}static setParams(...e){const t=new URLSearchParams(window.location.search);for(const[s,i]of e)t.set(s,i);return t}static makeState(e,t,s){const i={skills:t.skills.toJSON(),armor:t.armor,perkDeck:t.perkDeck,copycat:t.copycat,copycat_mimic:t.copycat_mimic,perk_deck_unlock:t.perk_deck_unlock,throwable:t.throwable,deployable:t.deployable,deployableSecondary:t.deployableSecondary,infamyDisabled:t.infamyDisabled};return s&&(i.tab=s),e&&(i.lang=e),i}static getNodeIndex(e,t=()=>!0){return[...e.parentNode.children].filter(t).indexOf(e)}static parentElement(e,t=1){let s=e;for(let e=0;e<t;e++)s=s.parentElement;return s}static findTouch(e,t){for(const s of e)if(s.identifier===t)return s;return!1}}class t extends Map{constructor(){super([[1,new Map],[2,new Map],[3,new Map],[4,new Map]]),this.tierPoints=new Map([[1,0],[2,0],[3,0],[4,0]]),this.maxTier=1,this.points=0}setSkill(e,t,s){const i=this.get(e);i.set(t,s),this.set(e,i),this.__updateTierPoints2(e,i),this.__updateTotalPoints()}set(e,t){super.set(e,t),this.tierPoints}deleteSkillUnknownTier(e){let t=0;for(const[s,i]in this)if(i.has(e)){t=s;break}return this.deleteSkill(t,e)}deleteSkill(e,t){const s=this.get(e),i=s.delete(t);return this.set(e,s),this.__updateTierPoints2(e,s),this.__updateTotalPoints(),i}__updateTierPoints2(e,t){let s=0;for(const i of[...t.values()])for(let t=1;t<=i;t++)s+=n.SKILL_COST_PER_TIER[e][t];this.tierPoints.set(e,s)}__updateTierPoints(e){this.__updateTierPoints2(this.get(e))}__updateTotalPoints(){this.points=[...this.tierPoints.values()].reduce((e,t)=>e+t,0)}getMaximumUnlockedTier(e){const t=n.getTierUtil(e);let s=1,i=0;for(let e=1;e<t.length&&(i+=this.tierPoints.get(e),i>=t[e]);e++)s++;return this.maxTier=s,s}getInvalidSkills(e,t=void 0){const s=void 0===t?this.getMaximumUnlockedTier(e):t;if(4==s)return[];let i=[];return[...this.keys()].filter(e=>e>s).forEach(e=>i.push(...this.get(e).keys())),i}}class s extends Map{constructor(...e){super(...e),this.points="9999"===location.port?1e3:100,this.subtrees=new Map}set_subtree(e,s,i,n){return super.set(e,s),this.subtrees.has(i)||this.subtrees.set(i,new t),this.subtrees.get(i).setSkill(n,e,s.state),this}set(e,t){return console.warn("Please avoid using SkillMap.set, please use SkillMap.set_subtree instead if possible"),super.set(e,t),this}delete_subtree(e,t,s){const i=super.delete(e);return this.subtrees.has(t)&&(void 0===s?this.subtrees.get(t).deleteSkillUnknownTier(e):this.subtrees.get(t).deleteSkill(s,e)),i}delete(e){return console.warn("Please avoid using SkillMap.delete, please use SkillMap.delete_subtree instead if possible"),super.delete(e)}getTierPoints(e,t,s){let i=0;for(const[n,r]of this){const o=s.get(n);o.subtree===t&&o.tier===e&&(2===r.state?i+=o.ace+o.basic:i+=o.basic)}return i}getTiersToFloorPoints(e,t,s){let i=0;for(let n=0;n<=e;n++)i+=this.getTierPoints(n,t,s);return i}toJSON(){const e={};for(const[t,s]of this)e[t]=s;return e}}class i extends Map{get(e){return super.get(e)}fetchAll(){const e=[];for(const[t]of this)e.push(fetch(`./db/${t}.json`).then(e=>e.json()).then(e=>{if("skills"===t||"perk_decks"===t)for(const s in e)e[s].stats&&("skills"===t?(e[s].stats.basic&&i.processModifiers(...e[s].stats.basic),e[s].stats.ace&&i.processModifiers(...e[s].stats.ace)):i.processModifiers(...e[s].stats));else if("perk_cards"===t){const t=[],s=[];for(const i in e)e[i].is_copycat_boost?t.push(e[i]):e[i].copycat_mimicry_available&&s.push(e[i]);this.set("copycat_boosts",new Map(Object.entries(t))),this.set("copycat_mimicry",new Map(Object.entries(s)))}this.set(t,new Map(Object.entries(e)))}));return Promise.all(e)}static processModifiers(...e){for(const t of e)if(t&&"string"==typeof t.value)return Function.apply({},[...t.arguments,`return (${t.value})`])}}class n{constructor(e){this.builder=e}Validate_Skills(t){const s=this.builder.exp,i=s.skills;let n=new Set;const r=void 0===t?i.subtrees.keys():[t];for(const e of r){const t=i.subtrees.get(e),r=t.getInvalidSkills(s.infamyDisabled);for(const e of r)n.add(e),this.Skill_Remove(e,!0);this.builder.gui.Subtree_MoveBackground(e,t.points)}if(this.builder.gui.Skill_UpdatePointsRemaining(s.skills.points),n.size>0){n.has("iron_man")&&"ictv"===s.armor&&(this.builder.gui.Armor_Unselect(),s.armor=null),n.has("jack_of_all_trades")&&(this.builder.gui.HandleJoat(!0),s.deployableSecondary=null,this.builder.gui.DeployableSecondary_Unselect());for(const e in n)this.builder.gui.HandleUnlocks({type:"skill",skill:e,unlocks:this.builder.dbs.get("skills").get(e).unlocks});window.history.pushState(e.makeState(null,this.builder.exp,this.builder.gui.Tab_Current),"removed invalid skills",this.builder.io.GetEncodedBuild())}}Skill_Add(e){const t=this.builder.exp,s=t.skills.get(e),i=this.builder.dbs.get("skills").get(e),r=t.subtrees[i.subtree],o=i.tier,l=r.tier;if(o>l)return console.error(`skill ID ${e} invalid.\nSkill tier ${o}, tree tier ${l}.\n(only ${r.points} pts in tier)\nSkill has not been added.`),!1;if(s){if(t.skills.points-i.ace>=0)return r.points+=i.ace,t.skills.points-=i.ace,s.state=2,t.skills.set_subtree(e,s,i.subtree,i.tier),r.tier=n.getSubtreeTierLevel(r.points,t.infamyDisabled),!0}else if(t.skills.points-i.basic>=0)return r.points+=i.basic,t.skills.points-=i.basic,t.skills.set_subtree(e,{state:1},i.subtree,i.tier),r.tier=n.getSubtreeTierLevel(r.points,t.infamyDisabled),!0;return!1}Skill_Remove(e,t=!1){const s=this.builder.exp,i=s.skills.get(e),r=this.builder.dbs.get("skills"),o=r.get(e);if(!i)return!1;if(!t)for(let e=o.tier;e<4;e++)if(0!==s.skills.getTierPoints(e+1,o.subtree,r)){const t=s.skills.getTiersToFloorPoints(e,o.subtree,r);if(2===i.state){if(t-o.ace<this.constructor.getTierUtil(this.builder.exp.infamyDisabled)[e])return!1}else if(t-o.basic<this.constructor.getTierUtil(this.builder.exp.infamyDisabled)[e])return!1}const l=s.subtrees[o.subtree];return 2===i.state?t?(l.points-=o.ace+o.basic,s.skills.points+=o.ace+o.basic,s.skills.delete_subtree(e,o.subtree,o.tier)):(l.points-=o.ace,s.skills.points+=o.ace,i.state=1,s.skills.set_subtree(e,i,o.subtree,o.tier)):1===i.state&&(l.points-=o.basic,s.skills.points+=o.basic,s.skills.delete_subtree(e,o.subtree,o.tier)),l.tier=n.getSubtreeTierLevel(l.points,s.infamyDisabled),!0}static getTierUtil(e){return e?this.TIER_UTIL_NON_INFAMY:this.TIER_UTIL}static getSubtreeTierLevel(e,t){const s=this.getTierUtil(t);let i=s.findIndex(t=>e<=t);return-1===i?i=s.length:i++,i}}n.TIER_UTIL=Object.freeze([0,1,4,16]),n.TIER_UTIL_NON_INFAMY=Object.freeze([0,1,4,16]),n.SKILL_COST_PER_TIER=Object.freeze({1:Object.freeze({1:1,2:3}),2:Object.freeze({1:2,2:4}),3:Object.freeze({1:3,2:6}),4:Object.freeze({1:4,2:8})});class r{constructor(){this.down=!1,this.contexts=[],this.curContext,document.addEventListener("mouseup",e=>{this.down&&0==e.button&&(e.preventDefault(),this.down=!1)}),document.addEventListener("mousemove",e=>{this.down&&this.curContext.element.scrollBy(e.movementX*this.curContext.multiply,0)},{passive:!0})}addContext(e,t=1,s=!0){const i={element:e,propagate:s,multiply:t};this.contexts.push(i),e.addEventListener("mousedown",e=>{0==e.button&&(this.down=!0,this.curContext=i,!s&&e.target.closest(".pk_deck_cards > div")&&e.stopPropagation(),e.preventDefault())})}}class o{constructor({click:t=()=>i.dispatchEvent(new MouseEvent("click",{detail:-1})),double:s=()=>i.dispatchEvent(new MouseEvent("contextmenu",{detail:-1})),element:i,mobile:n,hold:r,propagate:o=!1}){this.touchId=null,this.last=[],this.remaining=[],this.holding=!1,this.didDouble=!1,this.listen=!1;const l=e=>{if(e instanceof MouseEvent){if(o||e.stopPropagation(),0!=e.button)return}else{if(e.stopImmediatePropagation(),null!==this.touchId)return;const t=e.touches[0];this.touchId=t.identifier,this.last=[t.clientX,t.clientY]}this.remaining=[2*document.documentElement.clientWidth/100,2*document.documentElement.clientHeight/100],this.holding=setTimeout(()=>{this.holding=!0,this.touchId=null,this.listen=!1,r()},750),this.listen=!0},a=t=>{if(this.listen){if(t instanceof MouseEvent)this.remaining[0]-=Math.abs(t.movementX),this.remaining[1]-=Math.abs(t.movementY);else{const s=e.findTouch(t.changedTouches,this.touchId);if(!s)return;this.remaining[0]-=Math.abs(s.clientX-this.last[0]),this.remaining[1]-=Math.abs(s.clientY-this.last[1]),this.last=[s.clientX,s.clientY]}this.remaining.some(e=>e<=0)&&(clearTimeout(this.holding),this.touchId=null,this.listen=!1)}},u=i=>{if(!(!this.listen||i instanceof MouseEvent&&0!==i.button||i.touches&&e.findTouch(i.touches,this.touchId))){if(i.stopImmediatePropagation(),clearTimeout(this.holding),i instanceof MouseEvent)return this.listen=!1,void(this.touchId=null);if(i.preventDefault(),this.didDouble)return this.didDouble=!1,this.touchId=null,this.listen=!1,void s();this.didDouble=!0,setTimeout(()=>{this.didDouble&&(this.listen=!1,this.touchId=null,this.didDouble=!1,t())},300)}};i.addEventListener("touchstart",l),i.addEventListener("touchcancel",()=>this.touchId=null),i.addEventListener("touchmove",a),i.addEventListener("touchend",u),n&&(i.addEventListener("mouseup",u),i.addEventListener("mousemove",a),i.addEventListener("mousedown",l))}}export{e as default,s as SkillMap,i as DBMap,n as System,r as XScrollTransformer,o as UIEventHandler};
